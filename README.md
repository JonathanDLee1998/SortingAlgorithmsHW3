# SortingAlgorithms
Thankfully for me, we did the majority of this in class, but even that is not enough to grant me success. One of my main issues is as I tried to push the near finished code to my GITHUB, it was deleted from my pc. Thankful Proffessor Hegney was kind enough to let me clone her code. I put in my 5 unique students with their varying GPAs, and made all the different sorting methods. Insertion Sort is a straightforward and intuitive algorithm, akin to sorting playing cards in one’s hand. It builds the final sorted array one element at a time. The algorithm works by iterating through the array, starting from the second element. For each element, it compares it with the elements before it, shifting those elements that are greater to one position ahead to make space for the new element. This process is repeated until the entire array is sorted.
Despite its simplicity, Insertion Sort is efficient for small datasets or nearly sorted arrays, with a best-case time complexity of O(n) and a worst-case time complexity of O(n²). The primary advantage of Insertion Sort is its ability to sort an array in place without requiring additional memory, making it a suitable choice for memory-constrained environments.
Bubble Sort is one of the simplest sorting algorithms to implement and understand. It repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. This process is akin to "bubbling" the largest unsorted element to its correct position at the end of the list with each complete pass through the array.
While easy to implement, Bubble Sort is not suitable for large datasets due to its inefficiency, having a worst-case and average-case time complexity of O(n²). However, it can be optimized by recognizing that after each pass, the next largest element is in its correct place, allowing the algorithm to reduce the number of comparisons in subsequent passes. Despite its inefficiencies, Bubble Sort serves an educational purpose by illustrating fundamental algorithmic concepts such as iteration and swapping.
Selection Sort is another simple sorting algorithm, but with a different approach compared to Bubble Sort. It works by dividing the array into two parts: a sorted sublist of items which is built up from left to right at the front (left) of the array, and a sublist of the remaining unsorted items. The algorithm repeatedly selects the smallest (or largest, depending on the sorting order) element from the unsorted sublist, swaps it with the leftmost unsorted element, and moves the sublist boundaries one element to the right.
Selection Sort has a time complexity of O(n²) for both average and worst cases, making it inefficient for large lists. However, it performs well on small lists and has the advantage of making the minimum possible number of swaps, which can be beneficial in scenarios where writing to memory is costly. Selection Sort is also conceptually simple and useful for understanding the process of sorting through selection and swapping.
Merge Sort is a more advanced and efficient sorting algorithm that employs the divide-and-conquer strategy. It works by recursively splitting the array into two halves until each subarray contains a single element, then merges these subarrays back together in the correct order. The merging process involves comparing the smallest elements of each subarray and sequentially building a sorted array.
Merge Sort has a consistent time complexity of O(n log n) for all cases (best, average, and worst), making it significantly more efficient than the previously mentioned algorithms for large datasets. One of its key advantages is its stability, meaning that it preserves the relative order of equal elements, which can be crucial for certain applications. However, Merge Sort requires additional memory space proportional to the size of the array, which can be a drawback in memory-limited environments.
